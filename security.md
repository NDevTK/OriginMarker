> **Note:** This document outlines the security considerations and mitigations for the OriginMarker extension. It should be reviewed and updated regularly, especially when changes are made to the extension's functionality, dependencies, permissions, or build process, to ensure it accurately reflects the current security posture.

# Chrome Extension Security Audit: OriginMarker

## 1. Introduction & Architecture

This document reflects the security state of OriginMarker after an initial audit and subsequent hardening cycles. Recent updates from these review and hardening cycles have further addressed error handling, state consistency, and input validation, and fixed specific bugs related to storage interaction; additional recent hardening has further enhanced robustness through stricter type validation for all critical data retrieved from storage and by applying defensive coding practices for internal data handling (such as for marker encoding alphabets). **A subsequent review re-verified that the hardening measures and mitigations detailed in this document are implemented in the codebase.**

### GitHub Actions CI/CD Security

#### Build Workflow (`build.yml`)

The `build.yml` workflow includes a step that automatically formats code using Prettier and then commits and pushes these changes directly to the `main` branch. This behavior was temporarily changed to a `--check` mode but has been reverted to the auto-commit behavior as per user request. While this provides convenience by ensuring consistent formatting, it's important to note that it bypasses the standard pull request and review process for these automated changes to the `main` branch. This could also potentially lead to CI loops or unintended pushes if triggered by pull requests from forks under certain conditions. Users of this repository should be aware of this workflow automation.

**Purpose:** The "OriginMarker" Chrome extension provides an origin-dependent marker by changing the title of a designated bookmark to reflect the origin of the currently active tab.

**Main Components:**

- **`manifest.json`:** Defines permissions, CSP, background service worker, and options UI.
- **`background.js` (Service Worker):** Core logic for tracking active tabs, fetching origins, generating markers, and updating bookmarks.
- **`options.html` / `options.js`:** Provides a user interface for extension settings, including a reset function.
- **`static.js`:** Contains static data like the character sets for marker encoding.

**Key Functionalities:**

- Dynamically updates a specific bookmark's title based on the current tab's URL origin.
- Uses SHA-256 hashing with a unique, randomly generated `salt` to create a hash of the origin.
- Employs a custom `base2base` conversion function to transform the hexadecimal hash output into a more visually distinct emoji-based string for automatic markers.
- Allows users to set custom string markers for specific origins.
- Operates in an "auto" mode (emoji markers) or "manual" mode (generic marker unless customized).

## 2. Security Analysis & Findings

### Manifest Configuration

- **Permissions (`tabs`, `bookmarks`, `storage`):** Deemed appropriate and necessary for the extension's core functionality. No overly broad permissions requested.
- **Content Security Policy (CSP):**
  - ```json
    "extension_pages": "default-src 'none'; script-src 'self'; frame-ancestors 'none'; form-action 'none'; upgrade-insecure-requests; block-all-mixed-content"
    ```
  - This is a **strong CSP**, effectively mitigating common web vulnerabilities like XSS on extension pages by restricting script sources to the extension's own files and disallowing inline scripts or external resources. `frame-ancestors 'none'` protects against clickjacking.
- **Other Security Headers:**
  - ```json
    "cross_origin_embedder_policy": { "value": "require-corp" }
    "cross_origin_opener_policy": { "value": "same-origin" }
    ```
  - These headers are **well-configured** and enhance protection against cross-origin attacks and speculative execution side-channel attacks.

### Salt Management and Storage

- **Vulnerability:** The cryptographic `salt` (a UUID generated by `crypto.randomUUID()`) used for hashing origins is stored in a user-configurable storage area (`sync`, `local`, or `session`), selected via the extension's options. The default is `sync`.
- **Risk:** **If a user's Google account is compromised, or their local Chrome profile data (which caches synced storage) is accessed by malware, the `salt` can be exfiltrated if stored in `chrome.storage.sync`.** While this would allow an attacker with additional access to the user's bookmarks to deanonymize auto-generated markers, the core functionality of custom markers remains unaffected. This is a **notable privacy consideration** for users opting for synchronized storage. Storing the salt in `local` or `session` storage mitigates this specific cross-device exfiltration risk but means markers will be device/session-specific.

**Further Hardening (Post-Initial Audit):**

- **Salt Value Validation:** The logic in `background.js` (`setMode`) for handling the `salt` fetched from storage has been improved. It now regenerates the salt not only if it's `undefined`, but also if it's `null`, an empty string, or not a string type. This ensures a **valid, non-empty salt is always used** for auto-marker generation, logging a warning if an invalid stored salt was encountered and corrected.
- **Storage Type Validation:** The chosen storage type (`store` variable: 'sync', 'local', or 'session'), which dictates where the salt and other extension data are stored, is now validated upon loading from `chrome.storage.local` in both `background.js` and `options.js`. If an invalid value is found, it defaults to 'sync', and this correction is persisted. This **enhances robustness against corrupted configuration.**
  - **Broader Stored Data Type Validation:** Beyond salt and storage type, additional type validation has been implemented in `background.js` for other critical data loaded from storage. This includes ensuring the `bookmark` ID, user `mode`, and custom marker strings are of the expected string type. If malformed data (e.g., an incorrect type) is retrieved, a warning is logged, and the data is typically disregarded or reset to a default/undefined state, relying on subsequent logic to re-initialize or handle the absence of valid data. This **further enhances robustness against potential data corruption in `chrome.storage`.**

### General Error Handling

- **Weakness:** Previously, many asynchronous Chrome API calls (e.g., `chrome.bookmarks.update`, `chrome.storage.sync.set`) in `background.js` and `options.js` lacked explicit error handling. This has been largely addressed by adding `.catch()` blocks to Promise-based calls in `background.js` and by incorporating `chrome.runtime.lastError` checks within Promise wrappers in `options.js`. Errors from these operations are now logged to `console.error`. While this error logging does not currently extend to comprehensive user-facing UI alerts or automatic state reconciliation logic for _all_ types of failures, a key improvement has been made for critical initialization failures:
  - **Error Badge Notification:** If the extension fails to initialize its primary bookmark ID (a **critical failure** preventing normal operation), an **"ERR" badge** is now displayed on the extension icon to alert the user. This badge is cleared upon successful (re)initialization.
  - **Diagnostic Hardening:** Explicit `chrome.runtime.lastError` checks have been added in some asynchronous callbacks (e.g., `chrome.tabs.query` in `checkOrigin`) for more precise error logging, though failures in such areas are rare.
- **Risk:** Previously, unhandled promise rejections could lead to **silent failures of operations.** While errors are now logged to the console for better visibility, and critical initialization failures trigger a UI badge, other non-critical operational failures could still potentially lead to **inconsistent internal state** within the extension or unexpected behavior from the user's perspective if operations do not complete as expected. This remains primarily a **robustness and reliability concern** for non-critical paths.

### Detailed `background.js` Logic Issues

#### State Inconsistency on Storage Failure

- **Vulnerability:** Previously, if a storage operation (e.g., saving `salt`, `mode`, or `bookmark` ID) failed, the in-memory variables might have been updated regardless, leading to a **divergence between the extension's active state and its persisted state.** This could cause inconsistent behavior or reliance on settings that weren't actually saved.
- **Mitigation:** The refactoring of `setMode` and `initBookmark` in `background.js` now ensures that in-memory state variables (`salt`, `mode`, `bookmark`) are **only updated _after_ the corresponding `chrome.storage.local.set` or `chrome.storage[store].set` operation successfully completes.** If a storage write operation fails, an error is logged, and the in-memory variable retains its previous value (either the last successfully persisted state or `undefined` if being initialized). This **prevents the in-memory state from reflecting unconfirmed changes, significantly improving state consistency.**
- **Risk:** The primary risk of using incorrect `salt`, `mode`, or `bookmark` ID due to failed writes is now **substantially mitigated.** The extension will operate on the last known good configuration or fail to initialize critical components if initial setup cannot be persisted.
- **`initBookmark` Re-entrancy Prevention:** The `initBookmark` and `onPlaceholder` functions have been refactored using `AbortController`. If `initBookmark` is called (e.g., due to rapid bookmark removals or other events) while a previous `onPlaceholder` operation is still awaiting user action (naming a bookmark `*` or `**`), the earlier `onPlaceholder` call is now aborted. This **prevents a potential race condition** where an older, user-abandoned placeholder bookmark ID could be erroneously persisted after a newer initialization sequence has already begun, further enhancing state consistency during setup.

#### Stale `active_origin` in `onBookmarkChange`

- **Vulnerability:** This was a concern where `active_origin` read at the start of `onBookmarkChange` could become stale during subsequent asynchronous operations within the handler.
- **Mitigation:** The implementation now mitigates this by **capturing the relevant origin at the start of event processing** (before any `await` operations or debouncing delay within the core logic) and uses this captured value for saving custom markers. This ensures the marker is associated with the origin that was active when the bookmark change action was initiated by the user.
- **Risk:** The risk of custom markers being saved for the wrong origin due to this specific staleness issue has been **substantially mitigated** by the current implementation.

#### Clarification on `onBookmarkChange` and Asterisk Suffix & Custom Marker Clearing

- The `onBookmarkChange` function includes a check `if (e.title.endsWith('*')) return;`. This is an **intentional design choice** with two main effects:
  1.  **Ignoring Auto-Generated Markers:** It prevents markers that were automatically generated and set by the `setMarker` function (which always appends an `*`) from being incorrectly processed as new user-defined custom markers if a bookmark change event is fired for them (e.g., upon their creation/update by `setMarker`).
  2.  **Ignoring User-Set Titles Ending in `*`:** It also means that if a user manually renames a bookmark and the new title happens to end with an asterisk, this bookmark title will _not_ be saved as a custom marker for the current origin. The extension consistently avoids treating any bookmark title ending in `*` as a candidate for a custom marker. This ensures that such titles do not accidentally overwrite custom marker logic or get stored as if they were user-defined non-automatic markers.
- **Custom Marker Clearing Across Storage Types:** A bug was identified and fixed where clearing a custom marker (by setting the bookmark title to empty) would only work if the extension was using `sync` storage. The operation `chrome.storage.sync.remove()` was used directly. This has been **corrected by introducing a `removeData(key)` function** that respects the user-configured `store` type ('sync', 'local', or 'session'), ensuring custom markers can be reliably cleared regardless of the chosen storage strategy.

### Marker Encoding (`base2base`)

- **Note:** The `source` (hexadecimal characters) and `emoji` alphabets used by the `base2base` conversion function are fixed and publicly visible in `static.js`. The SHA-256 hash provides the cryptographic strength; the `base2base` conversion to emoji is **purely for obfuscation and visual distinction, not for security.**
- **Further Review (Post-Initial Audit):**
  - The `base2base` algorithm was **re-verified and found to be a standard, logically sound implementation** for its purpose.
  - The processing of the `emoji` array in `static.js` by `base2base` results in an alphabet composed of individual Unicode code points. This means that complex emojis (grapheme clusters made of multiple code points) are effectively broken down into these constituent points for the purpose of the destination alphabet. While this impacts the visual composition of the generated marker (it's an alphabet of individual code points, not necessarily whole visual emojis), the process is **deterministic and not a security concern.** The `source` (hex) alphabet is correctly defined and used.
  - As a minor defense-in-depth measure, the initialization of the `base2base` encoding function in `background.js` now uses **defensive copies** of the `source` and `emoji` alphabet arrays (i.e., `base2base([...source], [...emoji])`). This ensures that the function operates on a snapshot of these arrays, protecting against highly unlikely scenarios where the global alphabet arrays might be accidentally modified before `base2base` is initialized.

### Chrome Web Store Package Integrity
OriginMarker benefits from the Chrome Web Store's (CWS) enhanced security measures for extension uploads. If opted-in via the Developer Dashboard, CWS can require that all future extension package uploads are verified using a developer-provided public key. This means that even if a developer's account or publishing workflow were compromised, new versions cannot be uploaded unless they are signed by the developer's trusted private key.

This verification step is an additional layer of security. If an uploaded package passes this developer key verification, CWS then automatically repackages the extension with the standard CWS-managed private key before publication. This ensures the extension maintains its ID and is ultimately distributed with a signature trusted by Chrome, while providing stronger guarantees that only authorized versions are submitted by the developer. For enhanced supply chain security, it is assumed that OriginMarker is opted into this feature in the Chrome Web Store.

## 3. UI/UX and User Comprehension Issues

(This section describes issues that were largely related to the `options.html` page's clarity and user guidance. The 'Recommendations & Mitigations' section notes these as **ADDRESSED**.)

- **Clarity of Reset Function (`options.html`):**
  - **Issue:** The "Reset" button text ("Clear custom marker names", then "Done but feel free to click again :)") doesn't adequately explain that it also clears the `salt` (changing all auto-markers) and requires full re-setup.
  - **Risk:** **Users might click it without understanding the full data loss and re-initialization implications.**
- **Setup Guidance (`options.html`):**
  - **Issue:** Minimal and potentially confusing setup instructions (e.g., "folder" vs. bookmark, reliance on implicit `onPlaceholder` mechanism).
  - **Risk:** **High likelihood of user error and misconfiguration during setup.**
- **Misinterpretation of Emoji Meanings:**
  - **Issue:** The `emoji` array contains symbols (e.g., üîí, ‚úÖ, ‚ùì, ‚ùó) users might associate with website security status, which the extension doesn't provide.
  - **Risk:** **False sense of security or confusion about a site's trustworthiness based on the marker.**
- **Meaning of `*` Suffix on Markers:**
  - **Issue:** The UI doesn't explain that the `*` suffix on auto-generated markers indicates they are automatic and affects how they are handled (as detailed in the `onBookmarkChange` clarification above).
  - **Risk:** **User confusion about marker appearance and behavior.**

## 4. Potential Attack Vectors

(This section remains largely relevant as it describes theoretical vectors, some of which are inherent to extension models or user choices.)

### Salt Exfiltration and Marker Deanonymization

- **Scenario:** An attacker gains unauthorized access to the user's `chrome.storage.sync` data (e.g., through malware, compromised Google account). The attacker also needs separate access to the user's bookmark data.
- **Vector:** Retrieve `salt`, use known `source`/`emoji` alphabets and `base2base` logic to map emoji markers back to origin hashes.
- **Impact:** **Deanonymization of auto-generated markers, undermining the privacy feature.**

### Exploiting Lack of Error Handling & Logic Flaws

- **Scenario:** Intermittent Chrome API failures; race conditions during salt initialization or `active_origin` changes.
- **Vector:** Errors go unhandled, or critical operations use stale/undefined state.
- **Impact:** Inconsistent extension state, incorrect marker display (potentially misleading), failure to save data, or use of predictable hashes. (Primarily reliability issues, but severe inconsistency or use of predictable salt values has security implications). (**Note: Many of these have been significantly mitigated by recent hardening**).

### Interaction Risks with Other Extensions/Browser Features

- **Storage Interference:** Malicious extensions with broad permissions (or browser vulnerabilities) could directly read/write this extension's `chrome.storage.sync` data, stealing or tampering with the `salt`. This is a **primary vector for undermining privacy.**
- **Bookmark Manipulation:** Other extensions modifying bookmark titles can cause functional conflicts or user confusion. A malicious extension might try to spoof OriginMarker's visual style.
- **Web Page Interaction:** Direct attacks from web pages are **well-mitigated** by the lack of `externally_connectable` and strong CSP. Detection by pages is possible but hard to exploit due to the `salt`.

### Denial of Service / Annoyance via Rapid Bookmark Updates

- **Scenario:** Another extension with `bookmarks` permission, or a user manually editing with extreme rapidity, changes the title of OriginMarker's designated bookmark very frequently.
- **Vector:** Each eligible title change (not ending in `*`) on the designated bookmark triggers the `onBookmarkChange` handler in `background.js`. This handler performs cryptographic operations (SHA-256) and storage operations (`chrome.storage.sync` or `chrome.storage.local`) to save the custom marker.
- **Impact:**
  - If `chrome.storage.sync` is used, rapid operations can **exceed Chrome's rate limits** (e.g., `MAX_WRITE_OPERATIONS_PER_MINUTE`), causing subsequent storage attempts to fail. This would temporarily prevent new custom markers from being saved or cleared.
  - Increased CPU usage due to repeated hashing, though likely minor.
  - General operational unreliability for the custom marker feature during such an event.
- **Severity: Low.** This does not directly compromise data integrity or confidentiality but can degrade the user experience and reliability of the custom marker functionality.

## 5. Recommendations & Mitigations

### Salt Management & Initialization

- **Status: ADDRESSED.** **Warn Users:** A warning has been added to `options.html` directly below the storage area selection. This warning explains the privacy implications of using "Sync" storage for the `salt` (potential exfiltration if the user's Google account is compromised) versus "Local" storage (device-specific markers, no syncing but better privacy in that specific scenario).

- **Status: ADDRESSED & HARDENED.** **Offer Local Salt Option & Validate Salt/Store Types:** The extension allows users to select `local` (or `session`) storage for all data, including the `salt`, via the options page. This makes markers device-specific (or session-specific) and mitigates the risk of `salt` exfiltration through Chrome sync. The options page should ideally explain these trade-offs clearly. **Additionally, the `salt` value fetched from storage is now validated to be a non-empty string, and regenerated if invalid. The storage type preference itself is also validated upon loading, defaulting to 'sync' if corrupted.**

### Initial Bookmark Setup & UI/UX

- **Status: ADDRESSED.** **Explicit Setup Process:** The setup instructions in `options.html` have been significantly expanded and clarified to provide a more guided, step-by-step process for users to designate a bookmark for OriginMarker to use.
- **Note on User Confirmation for Setup:** A feature involving an explicit confirmation step via the options page (after a user names a bookmark `*` or `**` and before the extension fully adopts it) was previously considered. To maintain the current streamlined setup process, the project owner has decided against implementing this additional confirmation step at this time. This item is therefore considered **closed without action.** Any related experimental code has been removed from the codebase.
- **Status: ADDRESSED.** **Improve Reset Clarity:** The reset button text in `options.html` has been changed to "Clear All Extension Data (Resets Markers & Salt)". Additionally, `options.js` now implements a **custom modal dialog** (using HTML, CSS, and JavaScript within the options page) that appears when the reset button is clicked. This dialog details the irreversible nature of the action, specifying that it clears all settings, custom markers, and the unique `salt`, which will alter all automatic markers and may necessitate reconfiguration of any placeholder bookmark. The completion message has also been made more specific.
- **Status: ADDRESSED.** **Explain Emoji Meanings and Curate Emoji List:** A disclaimer has been added to `options.html` stating that emoji markers are for origin differentiation only and do not imply security endorsement or website status. Furthermore, the emoji list in `static.js` has been curated to remove symbols that could be easily misinterpreted as security indicators or warnings, and to remove duplicate entries.
- **Status: ADDRESSED.** **Explain `*` Suffix:** An explanation has been added to `options.html` detailing that the `*` suffix on markers indicates they are system-managed and that user-set markers should not end with `*` to be saved as custom.

**Overall UI Clarity Enhancement:** Beyond the specific points above, the entire `options.html` page has undergone a comprehensive review and iterative refinement of its textual content. This process has **significantly improved the clarity, accuracy, and user-friendliness** of all instructions and explanations, particularly concerning the setup process, custom marker management, the meaning and implications of the 'salt', the nuances of different storage area choices, and the behavior of automatic versus manual modes. These enhancements aim to empower users to make informed decisions and operate the extension securely and effectively.

### Error Handling & State Consistency

- **Status: ADDRESSED & ENHANCED.** **High Priority: Comprehensive Error Handling:** Robust error logging to `console.error` (via `.catch()` handlers for Promises or `chrome.runtime.lastError` checks for direct callbacks) has been implemented for all identified `chrome.storage` operations and other critical async calls (e.g., bookmark updates, initial bookmark fetching in `start()`). **Explicit `chrome.runtime.lastError` checks are present in key callbacks (e.g., `chrome.tabs.query`).**
- **Status: LARGELY ADDRESSED & IMPROVED.** **Medium Priority: State Management on Error:** Errors from critical storage operations are logged to the console. More importantly, the refactoring of `setMode` and `initBookmark` ensures that critical in-memory state variables (`mode`, `salt`, `bookmark`) are **only updated after their corresponding storage operations (`setData`, `setDataLocal`) complete successfully.** If a storage write fails, the in-memory state is not changed to the new intended value, thus preventing divergence between runtime state and persisted state. This means the extension will continue to use the last successfully saved state or, in the case of `initBookmark` failing to save a new bookmark ID, the in-memory `bookmark` variable will remain `undefined` (or its old value if clearing failed), correctly indicating that the setup is incomplete or compromised. **This has been further enhanced by making the `initBookmark`/`onPlaceholder` process robust against re-entrancy using `AbortController`. Additionally, a user-facing error badge on the extension icon now appears if critical bookmark initialization fails.**
- **Status: ADDRESSED & CORRECTED.** **Medium Priority: Review `onBookmarkChange` Logic:** The logic in `onBookmarkChange` now captures the relevant `active_origin` at the beginning of its processing sequence (specifically, before any debouncing delay or further asynchronous operations that could lead to context switches) and uses this specific origin value when saving the custom marker. This mitigates the previously identified risk of associating the marker with a stale origin. **Furthermore, a bug affecting the clearing of custom markers when using 'local' or 'session' storage has been fixed, ensuring consistent behavior across configured storage types.**
- **Status: ADDRESSED.** **Low Priority: Mitigate Rapid Bookmark Change Events:** The `onBookmarkChange` handler has been updated to use debouncing for processing custom marker changes. This prevents very rapid, successive bookmark title modifications (e.g., by another extension or rapid manual edits) from overwhelming storage APIs (especially `chrome.storage.sync` rate limits) or causing excessive computation. This **enhances the robustness of the custom marker feature** under such conditions.

### General

- **Maintain Manifest Security:** Continue to enforce the strong Content Security Policy and other security headers. **(Status: Re-verified as strong and well-configured post-initial audit).**

## 6. Permissions Justification

The extension requests the following permissions, all of which are **necessary** for its intended operation:

- **`tabs`:** Required to access the URL of the currently active tab to determine its origin.
- **`bookmarks`:** Required to create, read, and update the designated bookmark used for displaying the marker.
- **`storage`** (`local` and `sync`): Required to store user settings (mode, `salt`, bookmark ID) and custom markers.
