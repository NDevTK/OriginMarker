# Chrome Extension Security Audit: OriginMarker

## 1. Introduction & Architecture

**Purpose:** The "OriginMarker" Chrome extension provides an origin-dependent marker by changing the title of a designated bookmark to reflect the origin of the currently active tab.

**Main Components:**
*   **`manifest.json`:** Defines permissions, CSP, background service worker, and options UI.
*   **`background.js` (Service Worker):** Core logic for tracking active tabs, fetching origins, generating markers, and updating bookmarks.
*   **`options.html` / `options.js`:** Provides a user interface for extension settings, including a reset function.
*   **`static.js`:** Contains static data like the character sets for marker encoding.

**Key Functionalities:**
*   Dynamically updates a specific bookmark's title based on the current tab's URL origin.
*   Uses SHA-256 hashing with a unique, randomly generated `salt` to create a hash of the origin.
*   Employs a custom `base2base` conversion function to transform the hexadecimal hash output into a more visually distinct emoji-based string for automatic markers.
*   Allows users to set custom string markers for specific origins.
*   Operates in an "auto" mode (emoji markers) or "manual" mode (generic marker unless customized).

## 2. Security Analysis & Findings

### Manifest Configuration
*   **Permissions (`tabs`, `bookmarks`, `storage`):** Deemed appropriate and necessary for the extension's core functionality. No overly broad permissions requested.
*   **Content Security Policy (CSP):**
    *   `"extension_pages": "default-src 'none'; script-src 'self'; frame-ancestors 'none'; form-action 'none'; upgrade-insecure-requests; block-all-mixed-content"`
    *   This is a strong CSP, effectively mitigating common web vulnerabilities like XSS on extension pages by restricting script sources to the extension's own files and disallowing inline scripts or external resources. `frame-ancestors 'none'` protects against clickjacking.
*   **Other Security Headers:**
    *   `cross_origin_embedder_policy: { "value": "require-corp" }`
    *   `cross_origin_opener_policy: { "value": "same-origin" }`
    *   These headers are well-configured and enhance protection against cross-origin attacks and speculative execution side-channel attacks.

### Salt Management and Storage
*   **Vulnerability:** The cryptographic `salt` (a UUID generated by `crypto.randomUUID()`) used for hashing origins is stored in `chrome.storage.sync`.
*   **Risk:** If a user's Google account is compromised, or their local Chrome profile data (which caches synced storage) is accessed by malware, the `salt` can be exfiltrated. This is the most significant security weakness identified regarding privacy.

### Initial Bookmark Setup (`onPlaceholder()`)
*   **Vulnerability:** The `onPlaceholder()` function in `background.js`, which is responsible for identifying the primary bookmark the extension will use and its operating mode, listens for generic `chrome.bookmarks.onCreated` or `chrome.bookmarks.onChanged` events.
*   **Risk:** If a user is actively creating or renaming bookmarks during the extension's first run or after a reset, the extension might inadvertently associate itself with an unintended bookmark whose title happens to match the mode specifiers (`*` or `**`). This can lead to incorrect extension behavior (e.g., wrong mode, updating the wrong bookmark) and user confusion.

### General Error Handling
*   **Weakness:** Many asynchronous Chrome API calls (e.g., `chrome.bookmarks.update`, `chrome.storage.sync.set`) in `background.js` lack explicit `.catch()` handlers for promise rejections.
*   **Risk:** Unhandled promise rejections can lead to silent failures of operations, inconsistent internal state within the extension, or unexpected behavior from the user's perspective. This is primarily a robustness and reliability issue.

### Detailed `background.js` Logic Issues
*   **Salt Initialization Hazard during Startup:**
    *   **Vulnerability:** In `background.js`'s `start()` function, the `setMode(mode)` call (responsible for loading/initializing the `salt`) is not `await`-ed. If `checkOrigin()` is called before `salt` is properly loaded, `sha256()` might use an `undefined` or stale `salt`.
    *   **Risk:** Generation of predictable or incorrect emoji markers during a brief startup window.
*   **State Inconsistency on Storage Failure:**
    *   **Vulnerability:** Silent failures of `setData` or `setDataLocal` (due to lack of error handling) can cause in-memory state (`salt`, `mode`) to diverge from persisted storage.
    *   **Risk:** Use of stale/incorrect `salt` or `mode` on subsequent startups, undermining reliability and consistency of marker generation and user customizations.
*   **Stale `active_origin` in `onBookmarkChange`:**
    *   **Vulnerability:** `active_origin` is read at the start of `onBookmarkChange`. If it changes due to a concurrent `setMarker` operation while `onBookmarkChange` is awaiting its own async operations, `onBookmarkChange` uses the initial stale value.
    *   **Risk:** Custom markers might be saved for the wrong origin, or clearing markers could trigger updates based on incorrect state.
*   **Clarification on `onBookmarkChange` and Asterisk Suffix:**
    *   The `onBookmarkChange` function includes a check `if (e.title.endsWith('*')) return;`. This is an intentional design choice with two main effects:
        1.  **Ignoring Auto-Generated Markers:** It prevents markers that were automatically generated and set by the `setMarker` function (which always appends an `*`) from being incorrectly processed as new user-defined custom markers if a bookmark change event is fired for them (e.g., upon their creation/update by `setMarker`).
        2.  **Ignoring User-Set Titles Ending in `*`:** It also means that if a user manually renames a bookmark and the new title happens to end with an asterisk, this bookmark title will *not* be saved as a custom marker for the current origin. The extension consistently avoids treating any bookmark title ending in `*` as a candidate for a custom marker. This ensures that such titles do not accidentally overwrite custom marker logic or get stored as if they were user-defined non-automatic markers.

### Marker Encoding (`base2base`)
*   **Note:** The `source` (hexadecimal characters) and `emoji` alphabets used by the `base2base` conversion function are fixed and publicly visible in `static.js`. The SHA-256 hash provides the cryptographic strength; the `base2base` conversion to emoji is purely for obfuscation and visual distinction, not for security.

## 3. UI/UX and User Comprehension Issues

*   **Clarity of Reset Function (`options.html`):**
    *   **Issue:** The "Reset" button text ("Clear custom marker names", then "Done but feel free to click again :)") doesn't adequately explain that it also clears the `salt` (changing all auto-markers) and requires full re-setup.
    *   **Risk:** Users might click it without understanding the full data loss and re-initialization implications.
*   **Setup Guidance (`options.html`):**
    *   **Issue:** Minimal and potentially confusing setup instructions (e.g., "folder" vs. bookmark, reliance on implicit `onPlaceholder` mechanism).
    *   **Risk:** High likelihood of user error and misconfiguration during setup.
*   **Misinterpretation of Emoji Meanings:**
    *   **Issue:** The `emoji` array contains symbols (e.g., üîí, ‚úÖ, ‚ùì, ‚ùó) users might associate with website security status, which the extension doesn't provide.
    *   **Risk:** False sense of security or confusion about a site's trustworthiness based on the marker.
*   **Meaning of `*` Suffix on Markers:**
    *   **Issue:** The UI doesn't explain that the `*` suffix on auto-generated markers indicates they are automatic and affects how they are handled (as detailed in the `onBookmarkChange` clarification above).
    *   **Risk:** User confusion about marker appearance and behavior.

## 4. Potential Attack Vectors

### Salt Exfiltration and Marker Deanonymization
*   **Scenario:** An attacker gains unauthorized access to the user's `chrome.storage.sync` data (e.g., through malware, compromised Google account). The attacker also needs separate access to the user's bookmark data.
*   **Vector:** Retrieve `salt`, use known `source`/`emoji` alphabets and `base2base` logic to map emoji markers back to origin hashes.
*   **Impact:** Deanonymization of auto-generated markers, undermining the privacy feature.

### `onPlaceholder()` Misconfiguration
*   **Scenario:** User rapidly creates/renames bookmarks during initial setup.
*   **Vector:** Extension captures an unintended bookmark title for mode/salt.
*   **Impact:** Incorrect extension mode/salt, leading to flawed behavior and confusion.

### Exploiting Lack of Error Handling & Logic Flaws
*   **Scenario:** Intermittent Chrome API failures; race conditions during salt initialization or `active_origin` changes.
*   **Vector:** Errors go unhandled, or critical operations use stale/undefined state.
*   **Impact:** Inconsistent extension state, incorrect marker display (potentially misleading), failure to save data, or use of predictable hashes. (Primarily reliability issues, but severe inconsistency or use of predictable salt values has security implications).

### Interaction Risks with Other Extensions/Browser Features
*   **Storage Interference:** Malicious extensions with broad permissions (or browser vulnerabilities) could directly read/write this extension's `chrome.storage.sync` data, stealing or tampering with the `salt`. This is a primary vector for undermining privacy.
*   **Bookmark Manipulation:** Other extensions modifying bookmark titles can cause functional conflicts or user confusion. A malicious extension might try to spoof OriginMarker's visual style.
*   **Web Page Interaction:** Direct attacks from web pages are well-mitigated by the lack of `externally_connectable` and strong CSP. Detection by pages is possible but hard to exploit due to the `salt`.

## 5. Recommendations & Mitigations

### Salt Management & Initialization
*   **High Priority: Warn Users:** Clearly inform users about the `chrome.storage.sync` risk for the `salt`.
*   **Medium Priority: Offer Local Salt Option:** Allow users to store `salt` in `chrome.storage.local`, explaining trade-offs (device-specific markers).
*   **High Priority: Ensure Salt Availability:** In `background.js`'s `start()` function, `await` the `setMode(mode)` call before any operations dependent on the `salt` (like `checkOrigin`).

### Initial Bookmark Setup & UI/UX
*   **High Priority: Explicit Setup Process:** Revamp `options.html` for a guided bookmark selection process (e.g., user creates/renames a bookmark with a specific temporary title).
*   **Medium Priority: User Confirmation for Setup:** After a potential bookmark is identified, ask for user confirmation.
*   **High Priority: Improve Reset Clarity:** Update `options.html` text for the "Reset" button to be explicit about its full impact (clears salt, custom markers, placeholder settings; all auto-markers will change; requires re-setup).
*   **Medium Priority: Explain Emoji Meanings:** Add a disclaimer in `options.html` that emoji markers are for origin differentiation only and do not imply security endorsement. Consider curating the `emoji` list to remove overtly suggestive symbols.
*   **Medium Priority: Explain `*` Suffix:** Detail the meaning of the `*` suffix on auto-generated markers in `options.html`, including why titles ending in `*` cannot be set as custom markers.

### Error Handling & State Consistency
*   **High Priority: Comprehensive Error Handling:** Add robust `.catch()` handlers for all `chrome.storage` operations and other critical async calls. Log errors to `console.error`.
*   **Medium Priority: State Management on Error:** In error handlers, attempt to reconcile state or alert users to critical save failures.
*   **Medium Priority: Review `onBookmarkChange` Logic:** Re-evaluate `onBookmarkChange` to prevent issues with stale `active_origin` post-async operations, ensuring custom markers are saved for the correct, intended origin. The clarification on `endsWith('*')` confirms current behavior is intentional for differentiating auto vs. custom markers.

### General
*   **Maintain Manifest Security:** Continue to enforce the strong Content Security Policy and other security headers.

## 6. Permissions Justification

The extension requests the following permissions, all of which are necessary for its intended operation:

*   **`tabs`:** Required to access the URL of the currently active tab to determine its origin.
*   **`bookmarks`:** Required to create, read, and update the designated bookmark used for displaying the marker.
*   **`storage`** (`local` and `sync`): Required to store user settings (mode, salt, bookmark ID) and custom markers.
